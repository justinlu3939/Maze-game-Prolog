% Define the predicate to find the exit of the maze
find_exit(Maze, Actions) :-
    start_position(Maze, Start),
    valid_actions(Actions),
    traverse_maze(Start, Maze, Actions).

% Find the start position within the maze
start_position(Maze, (X, Y)) :-
    nth0(Y, Maze, Row),
    nth0(X, Row, s).

% Check if the list of actions is valid
valid_actions([]).
valid_actions([Action|Rest]) :-
    member(Action, [left, right, up, down]),
    valid_actions(Rest).

% Traverse the maze using the list of actions
traverse_maze(Position, Maze, []) :-
    at_exit(Position, Maze).
traverse_maze(Position, Maze, [Action|Rest]) :-
    move(Action, Position, NewPosition),
    valid_position(NewPosition, Maze),
    traverse_maze(NewPosition, Maze, Rest).

% Check if the current position is an exit
at_exit((X, Y), Maze) :-
    nth0(Y, Maze, Row),
    nth0(X, Row, e).

% Define movements based on actions
move(left, (X, Y), (X1, Y)) :- X1 is X - 1.
move(right, (X, Y), (X1, Y)) :- X1 is X + 1.
move(up, (X, Y), (X, Y1)) :- Y1 is Y - 1.
move(down, (X, Y), (X, Y1)) :- Y1 is Y + 1.

% Check if the new position is valid (not a wall or outside the maze)
valid_position((X, Y), Maze) :-
    nth0(Y, Maze, Row),
    nth0(X, Row, Cell),
    \+ member(Cell, [w]). % 'w' represents a wall